package edu.bjfu.lol.逻辑;

import java.util.Queue;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;

import edu.bjfu.lol.scenes.scene2d.动作.动作类;
import edu.bjfu.lol.scenes.scene2d.命令.命令类;
import edu.bjfu.lol.scenes.scene2d.命令.命令组装器类;
import edu.bjfu.lol.scenes.scene2d.命令.并行命令类;
import edu.bjfu.lol.screen.对战屏幕类;
import edu.bjfu.lol.utils.常量类;
import edu.bjfu.lol.utils.音乐播放完自动销毁类;
import edu.bjfu.lol.动态.对战中技能类;
import edu.bjfu.lol.动态.对战中英雄类;
import edu.bjfu.lol.动态.对战中阵容类;
import edu.bjfu.lol.静态.阵容类;

public class 战场逻辑类
{
	private boolean 是否是第一滴血 = true;
	private class 回合数改变动作类 extends 动作类
	{
		private int 回合数;
		private 回合数改变动作类(int 回合数)
		{
			this.回合数 = 回合数;
		}
		@Override
		public void 开始()
		{
			对战屏幕类.实例.设置回合数(回合数);
		}
	}
	private class 回合数改变命令类 extends 命令类
	{
		private int 回合数;
		private 回合数改变命令类(int 回合数)
		{
			this.回合数 = 回合数;
		}
		@Override
		protected 动作类 生成动作()
		{
			return new 回合数改变动作类(回合数);
		}
	}
	// 模拟阵容A和阵容B对战，战斗信息输出到控制台
	/**
	 * 返回控制对战展示的命令队列
	 */
	public Queue<命令类> 对战(阵容类 我方, 阵容类 敌方)
	{
		对战中阵容类 我方对战中阵容 = new 对战中阵容类(我方, true, "我方阵容");
		对战中阵容类 敌方对战中阵容 = new 对战中阵容类(敌方, false, "敌方阵容");
		对战中英雄类[] 我方英雄数组 = 我方对战中阵容.get对战中英雄数组();
		对战中英雄类[] 敌方英雄数组 = 敌方对战中阵容.get对战中英雄数组();
		// 为了根据先手值排序同号位英雄的数组
		对战中英雄类[] 出手英雄数组 = new 对战中英雄类[2];
		int 回合数 = 1;
		// 对战进行中
		while (我方对战中阵容.有人存活() && 敌方对战中阵容.有人存活())
		{
			Gdx.app.debug("战场逻辑类.对战", "================================================================================================================================================================================");
			Gdx.app.debug("战场逻辑类.对战", String.format("<第%d回合>\n", 回合数));
			Gdx.app.debug("战场逻辑类.对战", "================================================================================================================================================================================");
			命令组装器类.实例.添加命令(new 回合数改变命令类(回合数));
			输出英雄信息(我方对战中阵容, 敌方对战中阵容);
			if (回合数 > 1)
			{
				Gdx.app.debug("战场逻辑类.对战", "<双方阵容回复生命值>");
				并行命令类 并行回血命令 = new 并行命令类();
				for (int 下标 = 0; 下标 < 我方英雄数组.length; 下标++)
				{
					if (我方英雄数组[下标] != null && !我方英雄数组[下标].is阵亡())
					{
						我方英雄数组[下标].回复生命(并行回血命令);
					}
					if (敌方英雄数组[下标] != null && !敌方英雄数组[下标].is阵亡())
					{
						敌方英雄数组[下标].回复生命(并行回血命令);
					}
				}
				命令组装器类.实例.添加命令(并行回血命令);
			}
			// 生命值根据生命值状态变化
			Gdx.app.debug("战场逻辑类.对战", "<双方阵容生命值变化>");
			for (int 下标 = 0; 下标 < 我方英雄数组.length; 下标++)
			{
				if (我方英雄数组[下标] != null && !我方英雄数组[下标].is阵亡())
				{
					我方英雄数组[下标].变化生命值();
					判断并发布最近英雄阵亡事件(我方对战中阵容, 敌方对战中阵容);
				}
				if (敌方英雄数组[下标] != null && !敌方英雄数组[下标].is阵亡())
				{
					敌方英雄数组[下标].变化生命值();
					判断并发布最近英雄阵亡事件(敌方对战中阵容, 我方对战中阵容);
				}
			}
			我方对战中阵容.被通知敌方阵容状态(敌方对战中阵容);
			敌方对战中阵容.被通知敌方阵容状态(我方对战中阵容);
			// 出手，这里比如2号位置先手值比1号位置高也不会比1号位先出手
			for (int 下标 = 0; 下标 < 我方英雄数组.length && 我方对战中阵容.有人存活() && 敌方对战中阵容.有人存活(); 下标++)
			{
				Gdx.app.debug("战场逻辑类.对战", "***********************************************************************************************************************************************************");
				Gdx.app.debug("战场逻辑类.对战", String.format("<轮到%d号位>\n", 下标+1));
				Gdx.app.debug("战场逻辑类.对战", "***********************************************************************************************************************************************************");
				// 根据先手值排序
				出手英雄数组[0] = null;
				出手英雄数组 [1] = null;
				// 只有该位置有英雄且该英雄未阵亡才可以进入出手英雄数组，下同
				if (我方英雄数组[下标] != null && !我方英雄数组[下标].is阵亡())
				{
					出手英雄数组[0] = 我方英雄数组[下标];
				}
				if (敌方英雄数组[下标] != null && !敌方英雄数组[下标].is阵亡())
				{
					出手英雄数组[1] = 敌方英雄数组[下标];
				}			
				if (出手英雄数组[0] == null)
				{
					出手英雄数组[0] = 出手英雄数组[1];
					出手英雄数组[1] = null;
				}
				else if (出手英雄数组[1] != null)
				{
					int 先手值0 = 出手英雄数组[0].get对战中先手值();
					int 先手值1 = 出手英雄数组[1].get对战中先手值();
					// B先出手
					if (先手值1 > 先手值0)
					{
						对战中英雄类 用于交换的临时变量 = 出手英雄数组[0];
						出手英雄数组[0] = 出手英雄数组[1];
						出手英雄数组[1] = 用于交换的临时变量; 
					}
					// 相同则随机谁先出手
					else
					{
						if (计算类.随机布尔值())
						{
							对战中英雄类  用于交换的临时变量 = 出手英雄数组[0];
							出手英雄数组[0] = 出手英雄数组[1];
							出手英雄数组[1] =  用于交换的临时变量;
						}
					}
				}
				// 通过前面的排序按下标顺序出手
				for (int 出手编号 = 0; 出手编号 < 出手英雄数组.length; 出手编号++)
				{
					// 虽然通过前面的判断只有活着的英雄可以进入出手英雄数组，但是第二个出手的英雄有可能被第一个出手的打死所以还得判断
					if (出手英雄数组[出手编号] != null && !出手英雄数组[出手编号].is阵亡())
					{	
						对战中英雄类 出手英雄 = 出手英雄数组[出手编号];
						Gdx.app.debug("战场逻辑类.对战", "--------------------------------------------------------------------------------------------------------------------------------------------------------------");
						Gdx.app.debug("战场逻辑类.对战", String.format("<轮到英雄%s出手>\n", 出手英雄.get阵容名所在位置英雄名字()));
						Gdx.app.debug("战场逻辑类.对战", "--------------------------------------------------------------------------------------------------------------------------------------------------------------");
						// 相对于出手英雄的敌方阵容
						对战中阵容类 敌方阵容 = 出手英雄 == 我方英雄数组[下标] ? 敌方对战中阵容 : 我方对战中阵容;
						// 被动持续释放状态释放
						出手英雄.被动持续释放状态释放(敌方阵容);
						// 被冰冻、击飞、恐惧、眩晕、压制不可出手
						boolean is被冰冻 = 出手英雄.is对战中被冰冻();
						boolean is被击飞 = 出手英雄.is对战中被击飞();
						boolean is被嘲讽 = 出手英雄.is对战中被嘲讽();
						boolean is被眩晕 = 出手英雄.is对战中被眩晕();
						boolean is被压制 = 出手英雄.is对战中被压制();
						boolean is不可出手 = is被冰冻 || is被击飞 || is被眩晕 || is被压制;
						if (!is不可出手)
						{
							boolean is正在主动持续施法 = 出手英雄.释放主动持续施法(敌方阵容);
							// 当前回合持续施法，不可进行普通攻击或释放技能
							if (!is正在主动持续施法)
							{
								// 未被沉默则释放技能
								if (!出手英雄.is对战中被沉默() && !出手英雄.is阵亡() && !is被嘲讽)
								{
									对战中技能类[] 技能数组 = 出手英雄.get对战中技能数组();
									while (true)
									{
										// 由于技能可能刷新导致再次释放技能，所以设此标志用于判断是否还有技能可以释放
										boolean 释放过技能 = false;
										// 对于物理技能伤害可能由于反伤导致出手英雄死亡，所以还需判断，下同
										for (int 技能编号 = 0; 技能编号 < 技能数组.length && !出手英雄.is阵亡() && !is正在主动持续施法; 技能编号++)
										{
											if (敌方阵容.有人存活())
											{
												if (技能数组[技能编号].释放(敌方阵容, 出手英雄))
												{
													释放过技能 = true;
													// 释放完技能可能出手英雄处于正在持续施法状态
													is正在主动持续施法 = 出手英雄.is正在持续施法();
													判断并发布最近英雄阵亡事件(我方对战中阵容, 敌方对战中阵容);
													判断并发布最近英雄阵亡事件(敌方对战中阵容, 我方对战中阵容);
													我方对战中阵容.被通知敌方阵容状态(敌方对战中阵容);
													敌方对战中阵容.被通知敌方阵容状态(我方对战中阵容);
												}
											}
											else
											{
												// 游戏结束
												break;
											}
										}
										// 当没有技能可以释放时才跳出循环
										if (!释放过技能)
										{
											break;
										}
									}
								}
								// 持续施法阶段不可普通攻击
								if (!is正在主动持续施法)
								{
									// 普通攻击
									int 攻击总次数 = 出手英雄.get对战中攻击总次数();
									Gdx.app.debug("战场逻辑类.对战", String.format("<普通攻击总次数%d>\n", 攻击总次数));
									// 普通攻击之后可能会造成出手英雄死亡所以还需判断，下同
									for (int 攻击次数 = 0; 攻击次数 < 攻击总次数 && !出手英雄.is阵亡(); 攻击次数++)
									{
										对战中英雄类 敌方默认被攻击英雄 = 敌方阵容.get默认被攻击英雄(出手英雄);
										// 敌方已经全部阵亡
										if (敌方默认被攻击英雄 == null)
										{
											break;
										}
										Gdx.app.debug("战场逻辑类.对战", String.format("<第%d次攻击>\n", 攻击次数+1));
										出手英雄.普通攻击(敌方默认被攻击英雄, 0, true, 攻击次数 % 2 == 0);
										// 双方都有可能有人阵亡，所以双向都需判断，下同
										判断并发布最近英雄阵亡事件(我方对战中阵容, 敌方对战中阵容);
										判断并发布最近英雄阵亡事件(敌方对战中阵容, 我方对战中阵容);
										我方对战中阵容.被通知敌方阵容状态(敌方对战中阵容);
										敌方对战中阵容.被通知敌方阵容状态(我方对战中阵容);
									}
								}
							}
						}
						else
						{
							if (is被冰冻)
							{
								System.out.print("被冰冻，");					
							}
							if (is被击飞)
							{
								System.out.print("被击飞，");
							}
							if (is被眩晕)
							{
								System.out.print("被眩晕，");
							}
							if (is被压制)
							{
								System.out.print("被压制，");	
							}
							Gdx.app.debug("战场逻辑类.对战", "所以不可出手");
						}
					}
				}
			}
			if (我方对战中阵容.有人存活() && 敌方对战中阵容.有人存活())
			{
				并行命令类 并行命令 = new 并行命令类();
				我方对战中阵容.被通知时间已过一回合(并行命令);
				敌方对战中阵容.被通知时间已过一回合(并行命令);
				命令组装器类.实例.添加命令(并行命令);
				回合数++;
			}
		}
		// 战斗结束输出结果
		if (我方对战中阵容.有人存活())
		{
			Gdx.app.debug("战场逻辑类.对战", "<我方胜利!>");
		}
		else if (敌方对战中阵容.有人存活())
		{
			Gdx.app.debug("战场逻辑类.对战", "<敌方胜利!>");
		}
		else
		{
			Gdx.app.debug("战场逻辑类.对战", "<平局!>");
		}
		return 命令组装器类.实例.get命令队列();
	}
	private class 第一滴血动作类 extends 动作类
	{
		private Music 音效;
		private 第一滴血动作类()
		{
			音效 = Gdx.audio.newMusic(Gdx.files.internal(常量类.声音目录 + "FirstBlood.mp3"));
			音效.setOnCompletionListener(new 音乐播放完自动销毁类());
		}
		@Override
		public void 开始()
		{
			音效.play();
		}
	}
	private class 第一滴血动作命令类 extends 命令类
	{
		@Override
		protected 动作类 生成动作()
		{
			return new 第一滴血动作类();
		}
	}
	// 计算被攻击阵容英雄阵亡数，并通知于攻击阵容
	private void 判断并发布最近英雄阵亡事件(对战中阵容类 被攻击阵容, 对战中阵容类 攻击阵容)
	{
		int 阵亡数 = 被攻击阵容.get最近一次攻击造成英雄阵亡数();
		for (int i = 0; i < 阵亡数; i++)
		{
			if (是否是第一滴血)
			{
				命令组装器类.实例.添加命令(new 第一滴血动作命令类());
				是否是第一滴血 = false;
			}
			攻击阵容.被通知最近一次攻击敌方阵容有英雄阵亡();
		}
	}
	private void 输出英雄信息(对战中阵容类 阵容A, 对战中阵容类 阵容B)
	{
		Gdx.app.debug("战场逻辑类.输出英雄信息", "<双方本轮英雄信息>");
		对战中英雄类[] A英雄数组 = 阵容A.get对战中英雄数组();
		对战中英雄类[] B英雄数组 = 阵容B.get对战中英雄数组();
		for (int i = 0; i < A英雄数组.length; i++)
		{
			if (A英雄数组[i] != null && !A英雄数组[i].is阵亡())
			{
				A英雄数组[i].输出对战中英雄信息();
				Gdx.app.debug("战场逻辑类.输出英雄信息", "================================================================================================================================================================================");
			}
		}
		for (int i = 0; i < B英雄数组.length; i++)
		{
			if (B英雄数组[i] != null && !B英雄数组[i].is阵亡())
			{
				B英雄数组[i].输出对战中英雄信息();
				Gdx.app.debug("战场逻辑类.输出英雄信息", "================================================================================================================================================================================");
			}
		}
	}
}