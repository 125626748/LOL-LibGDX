package edu.bjfu.lol.动态;

import com.badlogic.gdx.Gdx;

import edu.bjfu.lol.scenes.scene2d.命令.并行命令类;
import edu.bjfu.lol.动态.对战中英雄类.被集火状态类;
import edu.bjfu.lol.逻辑.计算类;
import edu.bjfu.lol.静态.英雄类;
import edu.bjfu.lol.静态.阵容类;

public class 对战中阵容类
{
	private String 阵容名;
	private 对战中英雄类[] 对战中英雄数组;
	private int 最近一次攻击造成英雄阵亡数;
	private static final int[] 一三五位置默认攻击位置顺序数组 = {0, 1, 2, 3, 4};
	private static final int[] 二四位置默认攻击位置顺序数组 = {1, 0, 3, 2, 4};
	public 对战中英雄类 get被攻击英雄前方可为目标抵挡伤害英雄(int 被攻击英雄所在位置)
	{
		对战中英雄类 英雄 = 对战中英雄数组[被攻击英雄所在位置-1];
		switch (被攻击英雄所在位置) {
		case 3:
			if (对战中英雄数组[0] != null && !对战中英雄数组[0].is阵亡())
			{
				英雄 = 对战中英雄数组[0];
			}
			break;
		case 4:
			if (对战中英雄数组[1] != null && !对战中英雄数组[1].is阵亡())
			{
				英雄 = 对战中英雄数组[1];
			}
			break;
		case 5:
			if (对战中英雄数组[0] != null && !对战中英雄数组[0].is阵亡())
			{
				英雄 = 对战中英雄数组[0];
			}
			else if (对战中英雄数组[1] != null && !对战中英雄数组[1].is阵亡())
			{
				英雄 = 对战中英雄数组[1];
			}
			else if (对战中英雄数组[2] != null && !对战中英雄数组[2].is阵亡())
			{
				英雄 = 对战中英雄数组[2];
			}
			else if (对战中英雄数组[3] != null && !对战中英雄数组[3].is阵亡())
			{
				英雄 = 对战中英雄数组[3];
			}
			break;
		}
		return 英雄;
	}
	public 对战中英雄类 get受伤最重英雄(boolean is忽略隐身)
	{
		对战中英雄类 受伤最重英雄 = null;
		float 最小生命百分比 = Float.MAX_VALUE;
		for (对战中英雄类 英雄 : 对战中英雄数组)
		{
			if (英雄 != null && !英雄.is阵亡())
			{
				if (is忽略隐身 || (!英雄.is对战中隐身() || 英雄.is对战中被集火()))
				{
					float 生命百分比 = 英雄.get对战中生命值() * 1f / 英雄.get对战中最大生命值();
					if (最小生命百分比 >= 生命百分比)
					{
						最小生命百分比 = 生命百分比;
						受伤最重英雄 = 英雄;
					}
				}
			}
		}
		return 受伤最重英雄;
	}
	public 对战中英雄类[] get默认被攻击小范围英雄数组(对战中英雄类 攻击者)
	{
		return get被攻击英雄所在小范围英雄数组(get默认被攻击英雄(攻击者));
	}
	public 对战中英雄类[] get随机被攻击小范围英雄数组()
	{
		return get被攻击英雄所在小范围英雄数组(get随机被攻击英雄(true));
	}
	// 用于get被攻击位置周围小范围英雄数组(int 被攻击位置)的数组
	private final 对战中英雄类[] 被攻击位置周围小范围英雄数组 = new 对战中英雄类[4];
	public 对战中英雄类[] get被攻击英雄所在小范围英雄数组(对战中英雄类 被攻击英雄)
	{
		被攻击位置周围小范围英雄数组[0] = null;
		被攻击位置周围小范围英雄数组[1] = null;
		被攻击位置周围小范围英雄数组[2] = null;
		被攻击位置周围小范围英雄数组[3] = null;
		if (被攻击英雄 != null)
		{
			switch (被攻击英雄.get英雄所在位置())
			{
				case 1:
					被攻击位置周围小范围英雄数组[0] = 对战中英雄数组[0];
					被攻击位置周围小范围英雄数组[1] = 对战中英雄数组[1];
					被攻击位置周围小范围英雄数组[2] = 对战中英雄数组[2];
					break;
				case 2:
					被攻击位置周围小范围英雄数组[0] = 对战中英雄数组[0];
					被攻击位置周围小范围英雄数组[1] = 对战中英雄数组[1];
					被攻击位置周围小范围英雄数组[2] = 对战中英雄数组[3];
					break;
				case 3:
					被攻击位置周围小范围英雄数组[0] = 对战中英雄数组[0];
					被攻击位置周围小范围英雄数组[1] = 对战中英雄数组[2];
					被攻击位置周围小范围英雄数组[2] = 对战中英雄数组[3];
					被攻击位置周围小范围英雄数组[3] = 对战中英雄数组[4];
					break;
				case 4:
					被攻击位置周围小范围英雄数组[0] = 对战中英雄数组[1];
					被攻击位置周围小范围英雄数组[1] = 对战中英雄数组[2];
					被攻击位置周围小范围英雄数组[2] = 对战中英雄数组[3];
					被攻击位置周围小范围英雄数组[3] = 对战中英雄数组[4];
					break;
				case 5:
					被攻击位置周围小范围英雄数组[0] = 对战中英雄数组[2];
					被攻击位置周围小范围英雄数组[1] = 对战中英雄数组[3];
					被攻击位置周围小范围英雄数组[2] = 对战中英雄数组[4];
					break;
			}
		}
		return 被攻击位置周围小范围英雄数组;
	}
	public 对战中阵容类(阵容类 阵容, boolean is我方, String 阵容名)
	{
		英雄类[] 英雄数组 = 阵容.get英雄数组();
		对战中英雄数组 = new 对战中英雄类[英雄数组.length];
		for (int i = 0; i < 对战中英雄数组.length; i++)
		{
			if (英雄数组[i] != null)
			{
				对战中英雄数组[i] = new 对战中英雄类(is我方, 英雄数组[i], this, i+1);
			}
		}
		for (对战中英雄类 英雄 : 对战中英雄数组)
		{
			if (英雄 != null)
			{
				英雄.添加被动状态();
			}
		}
		this.阵容名 = 阵容名;
	}
	public String get阵容名()
	{
		return 阵容名;
	}
	public 对战中英雄类[] get对战中英雄数组()
	{
		return 对战中英雄数组;
	}
	public boolean 有人存活()
	{
		for (对战中英雄类 英雄 : 对战中英雄数组)
		{
			if (英雄 != null && !英雄.is阵亡())
			{
				return true;
			}
		}
		return false;
	}
	private 对战中英雄类 计算可能被攻击英雄(int 阵容被集火编号, 对战中英雄类 可能被攻击英雄, boolean 尚未有可能被攻击英雄)
	{
		对战中英雄类 被攻击英雄 = null;
		if (可能被攻击英雄 != null && !可能被攻击英雄.is阵亡())
		{
			int 英雄被集火编号 = 可能被攻击英雄.get对战中被集火编号();
			// 被集火
			if (可能被攻击英雄.is对战中被集火())
			{
				// 更靠最近被集火英雄
				if (英雄被集火编号 > 阵容被集火编号)
				{
					被攻击英雄 = 可能被攻击英雄;
				}
			}
			else
			{
				// 该英雄没有隐身且阵容中暂时前面尚未有可能被攻击对象
				if (!可能被攻击英雄.is对战中隐身() && 尚未有可能被攻击英雄)
				{
					被攻击英雄 = 可能被攻击英雄;
				}
			}
		}
		return 被攻击英雄;
	}
	private 对战中英雄类[] 竖排被攻击英雄数组 = new 对战中英雄类[2];
	public 对战中英雄类[] get竖排被攻击英雄数组(对战中英雄类 攻击者)
	{
		竖排被攻击英雄数组[0] = null;
		竖排被攻击英雄数组[1] = null;
		switch (攻击者.get英雄所在位置())
		{
			case 1:
			case 3:
			case 5:
				if (对战中英雄数组[0] != null || 对战中英雄数组[2] != null)
				{
					竖排被攻击英雄数组[0] = 对战中英雄数组[0];
					竖排被攻击英雄数组[1] = 对战中英雄数组[2];
				}
				else
				{
					if (对战中英雄数组[4] != null)
					{
						竖排被攻击英雄数组[0] = 对战中英雄数组[4];
					}
					else
					{
						竖排被攻击英雄数组[0] = 对战中英雄数组[1];
						竖排被攻击英雄数组[1] = 对战中英雄数组[3];
					}
				}
				break;
			case 2:
			case 4:
				if (对战中英雄数组[1] != null || 对战中英雄数组[3] != null)
				{
					竖排被攻击英雄数组[0] = 对战中英雄数组[1];
					竖排被攻击英雄数组[1] = 对战中英雄数组[3];
				}
				else
				{
					if (对战中英雄数组[4] != null)
					{
						竖排被攻击英雄数组[0] = 对战中英雄数组[4];
					}
					else
					{
						竖排被攻击英雄数组[0] = 对战中英雄数组[0];
						竖排被攻击英雄数组[1] = 对战中英雄数组[2];
					}
				}
				break;
		}
		return 竖排被攻击英雄数组;
	}
	public 对战中英雄类 get默认被攻击英雄(对战中英雄类 攻击者)
	{
		int 阵容被集火编号 = 被集火状态类.最大未被集火编号;
		对战中英雄类 已有被攻击英雄 = null;
		对战中英雄类 可能被攻击英雄 = null;
		boolean is获得攻击后排能力 = 攻击者.is对战中获得攻击后排能力();
		switch (攻击者.get英雄所在位置())
		{
			// 1、3、5号位
			case 1:
			case 3:
			case 5:
				if (is获得攻击后排能力)
				{
					for (int i = 一三五位置默认攻击位置顺序数组.length-1; i >= 0; i--)
					{
						可能被攻击英雄 = 计算可能被攻击英雄(阵容被集火编号, 对战中英雄数组[一三五位置默认攻击位置顺序数组[i]], 已有被攻击英雄 == null);
						if (可能被攻击英雄 != null && 可能被攻击英雄 != 已有被攻击英雄)
						{
							已有被攻击英雄 = 可能被攻击英雄;
							阵容被集火编号 = 已有被攻击英雄.get对战中被集火编号();
						}
					}
				}
				else
				{
					for (int i = 0; i < 一三五位置默认攻击位置顺序数组.length; i++)
					{
						可能被攻击英雄 = 计算可能被攻击英雄(阵容被集火编号, 对战中英雄数组[一三五位置默认攻击位置顺序数组[i]], 已有被攻击英雄 == null);
						if (可能被攻击英雄 != null && 可能被攻击英雄 != 已有被攻击英雄)
						{
							已有被攻击英雄 = 可能被攻击英雄;
							阵容被集火编号 = 已有被攻击英雄.get对战中被集火编号();
						}
					}
				}
				break;
			// 2、4号位
			case 2:
			case 4:
				if (is获得攻击后排能力)
				{
					for (int i = 二四位置默认攻击位置顺序数组.length-1; i >= 0; i--)
					{
						可能被攻击英雄 = 计算可能被攻击英雄(阵容被集火编号, 对战中英雄数组[二四位置默认攻击位置顺序数组[i]], 已有被攻击英雄 == null);
						if (可能被攻击英雄 != null && 可能被攻击英雄 != 已有被攻击英雄)
						{
							已有被攻击英雄 = 可能被攻击英雄;
							阵容被集火编号 = 已有被攻击英雄.get对战中被集火编号();
						}
					}
				}
				else
				{
					for (int i = 0; i < 二四位置默认攻击位置顺序数组.length; i++)
					{
						可能被攻击英雄 = 计算可能被攻击英雄(阵容被集火编号, 对战中英雄数组[二四位置默认攻击位置顺序数组[i]], 已有被攻击英雄 == null);
						if (可能被攻击英雄 != null && 可能被攻击英雄 != 已有被攻击英雄)
						{
							已有被攻击英雄 = 可能被攻击英雄;
							阵容被集火编号 = 已有被攻击英雄.get对战中被集火编号();
						}
					}
				}
			break;
		}
		return 已有被攻击英雄;
	}
	// 计算get随即被攻击英雄时避免多次new数组
	private final 对战中英雄类[] 随机被攻击英雄数组 = new 对战中英雄类[5];
	public 对战中英雄类 get随机被攻击英雄(boolean is忽略隐身)
	{
		int 存活数 = 0;
		for (对战中英雄类 英雄 : 对战中英雄数组)
		{
			if (英雄 != null && !英雄.is阵亡())
			{
				if (is忽略隐身 || !英雄.is对战中隐身())
				{
					随机被攻击英雄数组[存活数] = 英雄;
					存活数++;
				}
			}
		}
		if (存活数 > 0)
		{
			return 随机被攻击英雄数组[计算类.随机整数值(存活数)];
		}
		else
		{
			return null;
		}
	}
	/**
	 * 由该阵容中英雄调用通知该阵容最近一次攻击造成英雄死亡
	 */
	public void 被通知最近一次攻击造成本阵容有英雄阵亡(对战中英雄类 阵亡英雄)
	{
		最近一次攻击造成英雄阵亡数++;
		Gdx.app.debug("对战中阵容类.被通知最近一次攻击造成本阵容有英雄阵亡",String.format("%s，%d号位英雄阵亡\n", 阵容名, 阵亡英雄.get英雄所在位置()));
	}
	public void 被通知最近一次攻击敌方阵容有英雄阵亡()
	{
		for (对战中英雄类 英雄 : 对战中英雄数组)
		{
			if (英雄 != null && !英雄.is阵亡())
			{
				英雄.被通知敌方阵容有英雄阵亡();
			}
		}
	}
	public void 被通知敌方阵容状态(对战中阵容类 敌方阵容)
	{
		for (对战中英雄类 英雄 : 对战中英雄数组)
		{
			if (英雄 != null && !英雄.is阵亡())
			{
				英雄.被通知敌方阵容状态(敌方阵容);
			}
		}
	}
	public void 被通知时间已过一回合(并行命令类 并行命令)
	{
		for (对战中英雄类 英雄 : 对战中英雄数组)
		{
			if (英雄 != null && !英雄.is阵亡())
			{
				英雄.被通知时间已过一回合();
				英雄.重置特殊状态动画效果(并行命令);
			}
		}
	}
	private 对战中英雄类[] 横排被攻击英雄数组 = new 对战中英雄类[2];
	// 当技能需要攻击横排英雄时由该函数返回，调用者依然需要判断是否为null和是否阵亡，忽略隐身
	public 对战中英雄类[] get前排被攻击英雄数组()
	{
		横排被攻击英雄数组[0] = null;
		横排被攻击英雄数组[1] = null;
		if ((对战中英雄数组[0] != null && !对战中英雄数组[0].is阵亡()) || (对战中英雄数组[1] != null && !对战中英雄数组[1].is阵亡()))
		{
			横排被攻击英雄数组[0] = 对战中英雄数组[0];
			横排被攻击英雄数组[1] = 对战中英雄数组[1];
		}
		else if ((对战中英雄数组[2] != null && !对战中英雄数组[2].is阵亡()) || (对战中英雄数组[3] != null && !对战中英雄数组[3].is阵亡()))
		{
			横排被攻击英雄数组[0] = 对战中英雄数组[2];
			横排被攻击英雄数组[1] = 对战中英雄数组[3];
		}
		else
		{
			横排被攻击英雄数组[0] = 对战中英雄数组[4];
		}
		return 横排被攻击英雄数组;
	}
	/**
	 * 由战场逻辑类调用得知最近一次攻击造成该阵容的英雄阵亡数，该方法被调用之后将清空阵亡数，所以战场逻辑类必须在战场每发生一次攻击后都调用一次该方法
	 */
	public int get最近一次攻击造成英雄阵亡数()
	{
		int 阵亡数 = 最近一次攻击造成英雄阵亡数;
		最近一次攻击造成英雄阵亡数 = 0;
		return 阵亡数;
	}
}